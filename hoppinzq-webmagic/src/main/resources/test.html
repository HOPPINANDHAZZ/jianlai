<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>情景，如下图两个类：</p>
<p></p>
<p></p>
<p><img alt="" height="277" src="https://img-blog.csdnimg.cn/20210817102244849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTQ0Mjg5,size_16,color_FFFFFF,t_70" width="726"></p>
<p><img alt="" height="298" src="https://img-blog.csdnimg.cn/20210817094631301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTQ0Mjg5,size_16,color_FFFFFF,t_70" width="724"></p>
<p></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两个实体类A跟B，A的field有一个通过Autowired注入的实体类B。B有一个属性A，也是通过Autowired引入的。那么Spring在初始化实例化bean的过程会不会报错或者出现注入不进去的情况？答案是不会的。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;我们都知道spring启动的时候会执行refresh()方法去实例化bean并将其加入缓存，由源代码可以看出，该方法是加了synchronized同步锁的，只允许单线程操作，也就是说<span style="color:#be191c;"><strong>bean的实例化过程是肯定有先后顺序的</strong></span>。在refresh()方法中，通过finishBeanFactoryInitialization()方法实例化单例非懒加载的bean。</p>
<p><img alt="" height="708" src="https://img-blog.csdnimg.cn/20210817095504322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTQ0Mjg5,size_16,color_FFFFFF,t_70" width="1107"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; 符合条件的bean会调用getBean()和doGetBean()方法从三级缓存内寻找该bean的实例化对象，我们假设A类先被加载。显然在spring容器启动的时候三级缓存是不会存在A的实例化对象的，因此<span style="color:#be191c;"><strong>A类会先被实例化并放入三级缓存</strong></span>。然后装配A类的属性，也就是B类的实例化对象。在这个过程，spring由于扫描到了@Autowired注解，该注解通过doGetBean方法会从三级缓存内获取实体类B的实例化对象。由于B类此刻未被实例化，因此三级缓存没有B的实例化对象</p>
<p><img alt="" height="645" src="https://img-blog.csdnimg.cn/20210817101215615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTQ0Mjg5,size_16,color_FFFFFF,t_70" width="1200"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;通过doGetBean方法我们可以看到，如果在三级缓存内没有找到B的对象，那么<strong><span style="color:#be191c;">它会马上将B实例化并放入三级缓存</span>。</strong>此时，就开始B的实例化过程了：1、先判断三级缓存有B对象吗？显然没有，实例化B并放入三级缓存。2、装配B的过程发现了通过@Autowired注解引入的对象A，对象A在三级缓存吗？显然存在，那么B对象的装配就完成了。最后将装配完成的B对象去装配A对象，出栈！整个过程，思路清晰，行云流水。</p>
<p></p>
</body>
</html>