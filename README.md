# hoppinzq.com的后台框架————剑来！
![hoppinzq](https://images.gitee.com/uploads/images/2021/0930/192956_f3d9482b_5294558.png "hoppinzq.png")
![hoppinzqlogo](https://images.gitee.com/uploads/images/2021/0930/201304_6e8f53a0_5294558.gif "hoppinzqlogo.gif")
([hoppinzqlogo](http://hoppinzq.com:1234/zqproject/zqsvg.html))
#### 介绍
本项目是hoppinzq.com的后台框架，框架，框架！不是业务代码！语言是Java8，各个模块使用springBoot作为脚手架搭建。

#### 模块预览
+ 1、hoppinzq-service : 该模块负责服务的内部注册，如果业务模块需要注册服务以供其他模块或者第三方调用，需要引入该模块或者jar包。
+ 2、hoppinzq-client : 该模块负责服务调用，如果业务模块或者第三方需要调用通过hoppinzq-service注册的服务，需要引入该模块或者jar包。
+ 3、hoppinzq-service-common ：见名知意，为上面两个模块的公共部分。

  **以上三个模块可以按需引入，或者合并为一个独立的服务模块。**
+ 4、hoppinzq-service-core : 服务的注册中心模块，依赖于hoppinzq-service。该模块会通过hoppinzq-service去注册内部服务，其中包括注册服务，其他模块的服务需要通过hoppinzq-client去调用注册中心的注册服务来注册其内部服务的副本。所有服务将在一个List里面存根。
+ 5、hoppinzq-api-service : 业务模块（为什么起这个名字？因为该模块集成了一个zq-api中间件）。
+ 6、hoppinzq-service-gateway ：zq框架独有网关模块，将作为一个新的git项目讲解它。

#### 安装教程
1.  从git上拉取代码
2.  为hoppinzq-api-service配置数据源跟redis，空数据库即可，因为目前没有对数据库的操作。
3.  运行hoppinzq-service-core跟hoppinzq-api-service模块即可，控制台会打印返回注册服务接口的URL

#### Q&A
*  在该项目里，为什么采用Jetty作为web服务器而不是SpringBoot内置的Tomcat？这会增加我学习或使用的成本吗？
> 不，首先两者的实现都是遵循JavaServlet规范，因此在SpringBoot项目使用Jetty替换Tomcat你基本不需要改动一行代码。下面是采用Jetty的原因：  
1、Jetty是轻量的Web服务器，而Tomcat是重量级服务器。在很大的web项目使用Tomcat是完全没有问题，但是现在的项目经过分布式的拆分，每个模块负责的内容都少得多。这些模块
都去使用Tomcat作为Web服务器就是高射炮打蚊子，而用轻量级服务器Jetty能节省很多内存跟空间，这些节约的内存对服务器是极其宝贵的。  
2、Jetty的扩展性高，因为Jetty的架构是基于Handler来实现的，主要的扩展功能都可以用Handler来实现，扩展简单，你可以通过实现Filter接口很容易加一些自己的
功能：如代理转发、负载均衡、重定向、认证支持等。  
3、 Tomcat默认采用BIO处理IO请求，在处理静态资源时，性能较差。Jetty默认采用NIO去处理IO请求，在处理静态资源时，性能较高，
因而可以同时处理大量连接而且可以长时间保持连接。  
> 单就第三点就可以宣布Tomcat死刑，rpc框架的核心就是通过二进制流保持服务间的正常通讯。NIO就是异步IO，能够保证在并发的情况下服务的通讯不会被单个IO流阻塞，这就足够了。  

> ps:  你可以通过下面的方式移除SpringBoot默认的Tomcat服务器并启用(SpringBoot内置的)jetty服务器
> 
> ```<dependency>```  
> &emsp;&emsp;&emsp;```<groupId>org.springframework.boot</groupId>```  
> &emsp;&emsp;&emsp;```<artifactId>spring-boot-starter-web</artifactId>```  
> &emsp;&emsp;&emsp;```<exclusions>```  
> &emsp;&emsp;&emsp;&emsp;&emsp;```<exclusion>```  
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;```<groupId>org.springframework.boot</groupId>```  
> &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;```<artifactId>spring-boot-starter-tomcat</artifactId>```  
> &emsp;&emsp;&emsp;&emsp;&emsp;```</exclusion>```  
> &emsp;&emsp;&emsp;```</exclusions>```  
> ```</dependency>```  
>```<dependency>```  
> &emsp;&emsp;&emsp;```<groupId>org.springframework.boot</groupId>```  
> &emsp;&emsp;&emsp;```<artifactId>spring-boot-starter-jetty</artifactId>```  
> ```</dependency>```

*  在该项目里，服务是如何注册的？
> 1、在注册之前，你先要知道服务是如何存储的，在该项目里，服务是存储在一个线程安全的集合里，那么注册其实就是把服务的一些细节存入该集合内。下面就让我回答你的问题：服务注册在本项目分为两种，一种是通过自定义@ServiceRegister注解自注册，被该注解环绕的类在启动时会被注册到Spring容器内，因为只有服务类被实例化，我们才能通过反射获取这些服务类的信息。然后你要给每个需要进行服务注册的模块注册ProxyServlet这个Servlet，通过重写其内部的createServiceWrapper方法来将被注册到Spring容器内的@ServiceRegister环绕服务类增进服务集合。  
>2、能被注册进集合的服务并不是服务类，而是服务包装类ServiceWrapper。服务类在进行注册的时候，需要包装服务用户验证方式、服务鉴权方式、服务调用过程跟踪方式以及服务类，
> 你还可以拓展一些其他的参数包装在包装类内，如服务记录日志方式，服务提供者信息等等。  
>  3、注册中心模块就是通过上面的过程注册其内部服务，其中包括注册服务RegisterServer。因此，首先启动注册中心模块是很有必要的，因为外部服务就是通过RegisterServer的insert方法
进行注册。注意，根据配置是否开启严格模式，注册外部服务时注册中心的行为会有不同。在严格模式下，不允许新增相同的外部服务（你可以通过update更新服务）；反之，会覆盖相同的服务。注册进注册中心失败的服务将会进行注册重试。
> 值得注意：注册进注册中心的并不是服务类，而是模块内部注册服务的一份副本。因此，对于外部服务而言，注册中心只是起到了存根的功能，而不具备服务的真正注册或者服务代理转发。
![服务注册](https://images.gitee.com/uploads/images/2021/0917/170045_35e9a3be_5294558.png "服务注册.png")
* 在该项目里，服务是如何被发现的？
> 服务发现很简单，即把模块内部维护的服务集合的服务细节通过返回Html流或者一个接口暴露。在ProxyServlet类内，假如请求并没有被服务端正确解析，该请求将被我视为不是该框架的客户端发起
>的，此时将返回描述服务接口的HTML。你可以重写respondServiceHtml方法来实现你自己的服务发现。本项目的注册中心暴露了一个服务接口，你可以在com.hoppinzq.service.controller.ServiceController找到它。  
![服务发现](https://images.gitee.com/uploads/images/2021/0917/171131_966f0c9b_5294558.png "服务发现png.png")
* 在该项目里，服务之间是如何调用的？  
> 1、你首先要知道在分布式项目里，各个服务调用的方式都有那些，Feign跟HttpClient都是不错的选择，两个都是通过模拟HTTP请求来实现。  
2、本项目的服务之间通过http通讯，协议是在http报文后追加一段序列化的二进制数据流。各个模块之间严格按照这种通讯协议通讯，如果数据无法
被解析，那么这次请求将被我视为不是zq框架发起的，将在ProxyServlet的service方法抛出EOF异常而不是由Jetty抛出400响应码。  
3、本框架调用过程是这样的：假设有客户端A要调用服务端B的一个服务的一个方法，客户端A将会创建一个服务接口类的代理对象，然后客户端A在调用接口的方法时会被代理对象拦截，
由代理对象创建一个临时会话，然后将服务方法、传参、调用方信息序列化为一段二进制码，由Http发送该序列化的二进制码。服务端通过反序列化二进制码
得到客户端A封装的服务类、方法、参数、调用方信息等信息。服务端先通过服务类去其注册中心查询有无该服务,如果有服务，就拿到调用方信息去跟该服务注册时的用户验证
手段跟鉴权手段比对。鉴权成功后，拿到调用方信息中的类+方法+参数通过反射去调用服务的方法，获取返回数据。该过程的结果、异常都会通过序列化二进制流
返还给调用方。
![调用流程](https://images.gitee.com/uploads/images/2021/0918/003248_d6090f12_5294558.png "过程.png")
4、假设服务端有一个服务需要传入一个输入流，那么客户端在代理的时候会将其用一个标志类InputStreamArgument替换。服务端在反序列化的时候通过判断标志类InputStreamArgument判断是否重新直接获取http输出流作为传参。  
5、假设服务端有个服务方法只是对传参通过set方法等进行了修改，然后返回了void。遇到这种服务方法，必须在注册该服务前的时候将监听方式（SetterModificationManager）通过setModificationManager包装进来，然后客户端会去解析该类提供的修改列表，以便在客户端模拟服务端的修改过程。
![4跟5](https://images.gitee.com/uploads/images/2021/0922/161625_5352860e_5294558.png "407daf2737f11f790bfacfea8b1cd9d.png")
*  如果我先启动业务模块，后启动注册中心，我的业务模块的服务会注册成功吗？
>  maybe...在业务模块启动时将会把Spring容器内要注册的服务包装好，然后把注册中心的注册服务放在一个任务队列里。当项目启动成功后，会将任务队列内方法按序执行，也就是说业务模块的服务注册到注册中心的行为是发生在项目启动后。当注册中心没有启动时，注册服务将会抛出连接失败的异常。在任务队列里的方法都会被任务模板所装饰，而注册服务的方法被任务模板中的重试模板所环绕，任务模板会自动帮你执行注册工作，而重试模板会在抛出异常后进行重试（默认重试10次，每次1间隔分钟），也就是说默认只会在10分钟内重试，超过这个时间就不会自动注册了，此时需要你去写一个接口手动注册。
 ![服务注册重试](https://images.gitee.com/uploads/images/2021/0922/163253_35aca48d_5294558.png "c038868af81dff881921e89cb38f260.png") 
*  服务缓存是如何实现的？
>  这个问题是你不应该提出的，在RPC框架对服务缓存是没有任何意义的。这是因为服务方法调用过程是发生在服务端而不是客户端，你不应该指望在调用过一次服务后缓存该服务以便下一次调用在本地就可以实现。本框架对调用时的服务代理对象做了缓存，以便你不必为每次调用服务都要创建代理对象。你也可以缓存服务的返回值，以便调用同一个服务同一个传参直接从缓存中返回上次的数据，但是这种缓存将会交由你去实现。
*  服务心跳是如何实现的？
>  该框架的服务心跳机制跟其他RPC框架不同，我是这么实现的： 当客户端向服务端注册服务的时候会强制通过registerHeartbeatServiceNotCheck方法（该方法被final修饰，一定不能被重写）注册一个不会进行用户验证跟鉴权的心跳服务。此类服务会保存到注册中心一个单独的集合内。注册中心在启动的时候会不优雅的启动一个线程去轮询调用这些心跳服务，心跳服务将会返回其所在服务的IP地址。当调用失败时，将心跳服务包装服务中的IP的所有服务置为不可用。在严格模式下，不可用的服务将会从注册中心删除，防止重复注册。
*  服务的负载均衡是如何实现的？
>  负载均衡属于一个单独的模块，同样需要通过hoppinzq-service注册服务均衡服务，在启动负载均衡模块前需要为其配置服务所在的路径。负载均衡内部维护了一个网关，所有请求需要进入该网关，然后负载均衡服务会监听请求的响应时长，是否抛出异常等。通过同一个服务的同一个接口做横行对比为相同服务的相同接口之间设置权值。权重则是调用时长。每次请求都会通过负载均衡算法根据权值转发请求。负载均衡算法的实现原理是：假设有1个服务分别部署在三台服务器上，假设该服务有一个接口queryUesr用于查询用户信息。负载均衡模块在启动时会将该接口的每个服务设置随机权值1，2，3，总权值是6。当请求进入负载均衡模块后先判断哪个服务权值高，相同权值的服务将会随机选择一个服务转发请求。然后所有的服务在它的权值基础上加其本身的权值，此时的权值是2，4，6。由于总权值是6，此时权值大于等于6的权值会减去总权值，所以第一次调用后三个服务的queryUser接口的权值是2，4，0。第二次请求就来就是3，6，3，转发至第二个服务后变成3，0，3。然后是4，2，6，再调用第三个服务4，2，0。每次调用都会记录调用时长，动态改变权值，通过归一化算法让权值变化不是那么突兀
*  注册中心重启后需要重新注册服务吗？
>  不，注册中心支持热插拔，这是因为注册到注册中心的外部服务在注册中心不会存储具体的服务类，因此可以用IO流将注册中心的外部服务存到服务器的一个文件里，注册中心启动后先读取文件内容存至注册中心外部服务的缓存内，但是由于有严格模式的存在，在严格模式下，此法将会导致其他模块因为重启导致服务注册不成功。因此该功能已弃用，也就是说目前是注册中心重启，要么其他模块重启，要么其他模块维护一个重新注册服务的接口。
*  我不想将服务注册到注册中心了，可以注册到zookeeper上吗？
>  理论上是可以的，但是你要对本框架的注册过程十分了解。要注册到zookeeper上不需要重写很多方法，但是值得你注意的是：本框架的序列化框架是java自带的Serializable，如果你要实现dubbo+zookeeper这一套需要引入Hession序列化框架。很遗憾的是，笔者并没有注册到zookeeper的打算。
*  这个网关模块是干啥的？
>  这个网关旨在代理所有controller的功能，请求进入该网关后将会被自动分发至对应的service层，并会优雅的记录日志。它的原理是这样的：service层会通过ApiServiceMapping和ApiMapping注解注册其实现细节，就像swagger那两个注解，网关通过请求的细节去查找对应的服务并通过反射调用，然后返还给前台，在返回前通过Async注解异步将日志存入数据库中。你可能发现了，service层既暴露给前台又暴露给后台，承担的作用就跟controller一样，因此需要通过为其环绕ServiceLimit与Servicelock注解实现限流跟锁机制以避免重复请求与高并发出问题。 

...待补充

